# ddd - DDD123
# Library for procedural scene modelling.
# Jose Juan Montes 2020


from ddd.pipeline.decorators import dddtask
from ddd.ddd import ddd
import random
import noise
from ddd.util.common import parse_bool
from ddd.core.exception import DDDException
import math


@dddtask(select='[~"ddd:itemfill:@.*:types"]')
#@dddtask(select='[~"ddd:itemfill:@trees:types"]')
def ddd_common_itemfill(logger, pipeline, root, obj):

    for k, v in obj.extra.items():
        if k.startswith("ddd:itemfill:@") and k.endswith(":types"):
            
            #group_regexp = r'ddd:itemfill:@(P<group_name>[^:]+):types'
            group_name = k[len("ddd:itemfill:@"):k.find(":types")]

            item_types = obj.get("ddd:itemfill:@" + group_name + ":types")
            assert item_types

            item_density_m2 = float(obj.extra.get("ddd:itemfill:@" + group_name + ":density", 0.01))  # 0.001

            for o in obj.individualize(always=True).children:
                items = generate_area_items(o, obj.name + '_' + group_name, item_types, item_density_m2)

                # Do not add fill group if there are no items
                if items.children:
                    obj.append(items)

    #obj.dump()
    #obj.show()


def generate_area_items(area, group_name, item_types, item_density_m2=0.0025, item_align='noise', max_items=None):
    """
    Note that default density is low to prevent too many items being generated by default or by mistake. Adjust to your use case.
    """

    items = ddd.group2(name="Items Fill %s: %s" % (group_name, area.name))

    if not area.geom:
        return items

    item_area = area  # area.intersection(ddd.shape(osm.area_crop)).union()

    if item_align == 'noise':

        # Decimation would affect after
        num_items = int((item_area.geom.area * item_density_m2))
        #if num_items == 0 and random.uniform(0, 1) < 0.5: num_items = 1  # alone items
        if max_items:
            num_items = min(num_items, max_items)

        def filter_func_noise(coords):
            val = noise.pnoise2(coords[0] * 0.1, coords[1] * 0.1, octaves=2, persistence=0.5, lacunarity=2, repeatx=1024, repeaty=1024, base=0)
            return (val > random.uniform(-0.5, 0.5))

        for idx, p in enumerate(item_area.random_points(num_points=num_items)):
            item_type = ddd.random.weighted_choice(item_types)
            item = ddd.point(p, name="Item (%s/%s/%s) %s" % (group_name, area.name, item_type, idx))
            item.extra['ddd:itemfill:status'] = 'added'
            item.extra['ddd:item'] = item_type
            item.set('ddd:elevation', 'terrain')
            items.append(item)

    elif item_align == 'grid':

        # Give some margin for grid, and check the area is still a polygon
        item_area = item_area.buffer(-1.0)
        if item_area.is_empty() or item_area.geom.geom_type != "Polygon":
            return items

        (major_seg, minor_seg, angle) = ddd.geomops.oriented_axis(item_area)

        # Decimation would affect this afterwards
        num_items = int((item_area.geom.minimum_rotated_rectangle.area * item_density_m2))
        major_minor_ratio = major_seg.geom.length / minor_seg.geom.length
        items_major = int(max(1, math.sqrt(num_items) * major_minor_ratio))
        items_minor = int(max(1, math.sqrt(num_items) * (1 / major_minor_ratio)))

        minor_seg_centered = minor_seg.recenter()
        for i in range(items_major):
            p_major = major_seg.geom.interpolate(i * major_seg.geom.length / (items_major - 1 if items_major > 1 else 1))
            for j in range(items_minor):
                p_minor_offset = minor_seg_centered.geom.interpolate(j * minor_seg_centered.geom.length / (items_minor - 1 if items_minor > 1 else 1))
                p = (p_major.coords[0][0] + p_minor_offset.coords[0][0], p_major.coords[0][1] + p_minor_offset.coords[0][1])

                if not item_area.contains(ddd.point(p)):
                    continue

                item_type = ddd.random.weighted_choice(item_types)
                item = ddd.point(p, name="Item (%s/%s/%s) %s" % (group_name, area.name, item_type, idx))
                item.extra['ddd:itemfill:status'] = 'added'
                item.extra['ddd:item'] = item_type
                item.set('ddd:elevation', 'terrain')
                items.append(item)

    else:
        raise DDDException("Invalid item align type: %s", item_align)

    return items
